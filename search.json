[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Hello my friend!\nHere you can find everything you need about these projects! Just select what you need from the left menu."
  },
  {
    "objectID": "documentation/yulc/yulc.html",
    "href": "documentation/yulc/yulc.html",
    "title": "YULC",
    "section": "",
    "text": "Current hw rev: 2.1\nSoon available here!\nYULC is your future-proof perfect mate for powering your lightings at 5, 12 or 24V. Thanks to its compact form factor, it can be placed almost everywhere, it features a lot of protections to ensure safety for both the charger and the strips, and in the meanwhile, can provide a lot of juice to feed very power-hungry lights setup.\nIt also boasts an handy built-in buck regulator that from a maximum of 24V ensures safe 5V or 12V to your output. This mean that is also possible to use 18,19,…,24V external power supply (USB-C or barrel jack) taking advantage of their higher total power output and converting them to 5V or 12V increasing the output current.\nFurthermore, on the back of the board there is a powerful ESP32-S3, directly programmable through the USB-C, that allows you to manage even more complex effects and to run heavy tasks.\nSo, in few words, YULC consists in a full-featured board that can replace a lot of wiring messes, optimizing space and debug time in a reliable way.",
    "crumbs": [
      "YULC"
    ]
  },
  {
    "objectID": "documentation/yulc/yulc.html#how-does-it-work",
    "href": "documentation/yulc/yulc.html#how-does-it-work",
    "title": "YULC",
    "section": "How does it work",
    "text": "How does it work\nHere you can have a look to how the power path works:\n\n\n\n\n\nThere are two power stages. The main one for the led stips and one dedicated to the ESP32\nPowering all the logic and the ESP32-S3 with a dedicated secondary power stage without relying on the main one ensures that in case of a blowing fuse, everything will still work as expected. So replacing the fuse on-the-fly will be the only thing you’ll need to be again ready to go.",
    "crumbs": [
      "YULC"
    ]
  },
  {
    "objectID": "documentation/yulc/yulc.html#sec-settings_explanation",
    "href": "documentation/yulc/yulc.html#sec-settings_explanation",
    "title": "YULC",
    "section": "YULC settings explanation",
    "text": "YULC settings explanation\nThis is an interactive view of all the YULC possible settings:\n\n\nThis is a full-detailed version.\n\n\n\n\n\n\nThis is the main jumper that you have to select before anything else and before powering the board. If you join the EXT pins, YULC will be powered through the barrel jack power supply, not through the USB-C. So you can use a power supply up to 24V and then decide if you want to buck it to 5V or 12V or use it directly to the output bypassing the buck converter. With this selection, you are also able to safely program YULC through the USB-C while powering everything from the external power supply thanks to a back-to-back mosfet configuration. To do that you have to select 5V from the PD selection voltage (2). There will also be those 5V on the board but they won’t power anything (To prove that just disconnect the barrel jack power supply and the board will be turned off).\n\nInstead, if you select USB pins, everything will be powered from the USB-C according to the voltage selected. As before, you can choose to buck the voltage to 12 or 5V or use it directly.\n\n\n\n\n\n\nWarning\n\n\n\nWhen selecting USB, do not connect the barrel jack!\n\n\n\nUSB-C PD Voltage selection. Note that these voltages are the one you are asking for to the charger, not the ones you’ll surely have on the board. Selecting 20V, if the charger can provide them, the negotiation will end successfully, mosfets will let current flow and everything will be powered on. But if the charger is not able to do that, the negotiation will fail and the board will stay off. To help you debug that, the leds “OK” or “BAD” will lights up according to the negotiation result. Pay attention to the chargers you want to use. It should have a label with the list of voltages it can provide, so be sure to ask for that supported voltages, otherwise the negotiation will fail. Also consider the amount of power you need for your led strips and the power the charger can give. Chargers with the USB-A output will not work, even selecting 5V on YULC. Only Type-C Power Delivery chargers are compatible\n\n\n\n\n\n\n\nWarning\n\n\n\nE.g. If you have 5V strips like WS2812b and you want 6A at the output (so 30W), be sure to ask the for a voltage/current combo the charger can offer that can give those 30W and than buck it to 5V through the converter to have the current you want at the output.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nBe sure to select the closest combination of power and input voltage to what you need. If you need the buck IC to regulate at 5V, an input voltage of 9V or 12V will be better than a 24V from the heating point of view. The voltage difference (Vin - Vout) is smaller, so the inductor is “less stressed” -&gt; less ripple current -&gt; less heat. So you need the best trade-off with a quite close input voltage and enough power for your application.\n\n\n\nThis is the buck converter output regulation. Populate horizontally the pairs of pins according to the voltage you want to have at the output. If your input is lower or same as the output, just do not use the buck converter and route it directly but keep it populated even if you don’t use it. The buck IC will automatically enter in an energy save mode when the load is really small or even is not present. The same voltage will be shared across the two channels You can source up to 20A from the IC.\n\n\n\n\n\n\n\nWarning\n\n\n\nWith high watts at the output the board’s temperature will increase, so please always use the given heatsinks (both for the IC and the inductor) and the 5V fan to be on the safe side.\n\n\n\nThese two fuse holders are not one for channel as it could seem. The two channels share the same fuse. But there are two fuses because you have to select only one at a time according to what output you need. If you need the buck converter you have to populate the REGULAT. OUT fuse. Otherwise, if you want the input voltage routed directly to the output, populate the DIRECT OUT one. These holders are compatible with both the standard automotive blade fuses and the mini blase fuses, but for higher currents the standard blade fuse is suggested thanks to a better contact with the holder’s metal\n\n\n\n\n\n\n\nWarning\n\n\n\nNever populate both of them at the same time, it will short the regulator IC.\n\n\n\nYULC’s has 10 output terminals, 5 for each channel: 2x Positive terminal, 2x GND terminal, 1x Data terminal.\nEach terminal can handle up to 15A, so it’s heavily suggested to use both the pairs of the positive terminal and negative terminal, to decrease the overall resistance and to inject power easier later in the strips. Each channel is equipped with a level shifer to its data output and a high side power N-mosfet, in order to save a lot of power for longer strips in the idle state. These mosfets can also be used to control simpler strips through PWM, so you can easily control different combinations of type of strips using both the channels. Plase attach the given heatinsks to them to keep them cool when switching high currents\nYULC exposes also some pins through breadboard-friendly headers. You can use these to connect buttons/microhpones/potentiometers but you can also increase the number of output channels but consider that they don’t have level shifters and that you should take the power from the dedicated output terminals\n\n\nGPIO HeaderGPIO Used\n\n\n\n\n\nPin\nFunction\n\n\n\n\nGPIO 6\nIO\n\n\nGPIO 5\nIO\n\n\nGPIO 4\nIO\n\n\nGPIO 38\nIO\n\n\nGPIO 37\nIO\n\n\nGPIO 36\nIO\n\n\n3V\nPower\n\n\nGND\nGround\n\n\nGPIO 44\nTX\n\n\nGPIO 43\nRX\n\n\n\n\n\n\n\n\nPin\nFunction\n\n\n\n\nGPIO 0 (DO)\nBoot/User Button\n\n\nGPIO 1 (DO)\nLed Data 1\n\n\nGPIO 2 (DO)\nLed Data 2\n\n\nGPIO 47 (DO)\nMosfet 1\n\n\nGPIO 21 (DO)\nMosfet 2\n\n\nGPIO 7 (AI)\nFuse sense",
    "crumbs": [
      "YULC"
    ]
  },
  {
    "objectID": "documentation/yulc/yulc.html#first-installation",
    "href": "documentation/yulc/yulc.html#first-installation",
    "title": "YULC",
    "section": "First installation",
    "text": "First installation\nThis board does not have a “full closed” enclosure, because it needs a lot of air flow while stressing it with a lot of output current. So actually the “enclosure” will consists in two pieces: a simple flat base to screw to YULC with 3 M2 screws and the fan holder.\n\nStep 1\nFirst attach the inductor heatsink (the biggest one) as far to the right as possible, almost touching the fuse holder. Doing this way there is enough space for the regulator heatsink.\n\n\n\n\n\n\nWarning\n\n\n\nPay attention to place the heatsink in a way that it does not touch any other components, in particular the regulator IC one\n\n\nIn the end you can place the two heatsinks for the mosfet and then mount YULC on the base locking it in place with the help of the three smallest M2 screws\n\n\n\n\n\n\n\nStep 2\nUse other 4 M2 screws to mount the facing down fan on top of the holder and then connect it to YULC thorugh the dedicated JST connector.\n\n\n\n\n\n\n\n\n\n.\n\n\n\n\n\n\n\n.\n\n\n\n\n\n\n\nStep 3\nNow, with the help of the two longer screws, connect the fan holder to the two pillars of the base\n\n\n\n\n\nYour YULC is completely assembled, you can proceed with the software configuration\n\n\nBonus\n\nDIN BRACKET\nThe base has two more holes for M2 screws that can be used to design other types of support, like a din-mounting bracket, taken from thingiverse and modified a bit.\n\n\n\n\n\nIf you want to install something like this, you have to do that before STEP 1\n\n\nINMP441 Mic Adapter\nIf you would like to use the INMP441 microphone breakout board in combination with the Sound Reactive usermod, you can find here the gerber file of the tailor-made adapter.\n\n\n\n\n\n\n\n\n\n.\n\n\n\n\n\n\n\n.\n\n\n\n\n\nIt uses the following pins:\n\n\n\nYULC Pin\nINMP441 Pin\n\n\n\n\n3V\n3V\n\n\nGPIO 43 (TX)\nSD\n\n\nGPIO 44 (RX)\nWS\n\n\nGND\nGND, L/R\n\n\nGPIO 38\nSCK",
    "crumbs": [
      "YULC"
    ]
  },
  {
    "objectID": "documentation/yulc/yulc.html#sec-softwareconfs",
    "href": "documentation/yulc/yulc.html#sec-softwareconfs",
    "title": "YULC",
    "section": "Software configuration",
    "text": "Software configuration\n\nWLED\nWled for YULC is a manually compiled build, based on the v0.15.0-b5 “Kosen”. It features 4 usermods: Audio Reactive, Internal Temperature v2, MultiRelay and one I created for myself to use the connected strip as a timer bar.\n\n\n\n\n\nAUDIO REACTIVE\nThanks to the powerful ESP32-S3, you can really take adavantage of this integration while driving complex effects on really long strip. Yuo have multiple pins on the exposed header that you can use to read an I2S microphone. See INMP441 pcb adapter.\nINTERNAL TEMPERATURE v2\nWith this great usermod, we can directly monitor the temperature of the microcontroller thanks to the built-in temperature sensor. YULC has the ESP32-S3 placed on the bottom side and quite close to the buck converter zone, the main heat generator. Starting with a light load, the usermod temperature and the one measured on the inductor are quite similar, but the uC it’s slower to cool down. This allows to know the S3 temperature and to safely overestimate by 4/5°C the inductor temperature.\nKnowing this, I slightly modified the usermod with small but significant changes.\n\nTemperature measurement it’s enabled by default.\nHardcoded chip 70°C limit for overtemperature protection\nWhen the S3 will reach 70°C, the strip brightness will automatically drop to 0%, turning off the light.\nYULC will restore the default behaviour when temperature will decrease below 60°C.\n\nYou don’t need to configure anything on this usermod, it will start to work out of the box. This allows to safely use YULC even if the fan stops working for some reasons.\nYou can monitor the internal temperature inside the “Info” page:\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAltough YULC can work giving max 20A from the buck converter, the board is shipped with a 15A fuse and a max 12/13A current limiting from WLED settings is heavily suggested to be on the safe side and to keep relative cool temperatures. As long as the fan it’s working the internal temperature won’t rise above 60/65 °C (ambient temperature + increasing) at max load but if you would really need to use full 20A at a particular voltage, you must consider to change your type of strips to one that can work with higer voltages, decreasing the needed current, injection points keeping everything safer.\nAlways remember to set the current limiting option according to your setup, leaving the on-board fuse as a short-circuit only protection. So, go to Config -&gt; Led Preferences and set everything you need:\n\n\n\n\n\n\n\nMULTI RELAY\nNatively WLED only support one pin (usually connected to a relay) to physically turn on and off the light strips. While you can always use one of the exposed pins to wire an external relay, the built-in hardware already allows you to drive the two channels independently and each with its own power mosfet to toggle the strips. And thanks to this usermod, you can fully take advantage of it. This is valid if you want to connect two addressable strips, but, for example, if you want to connect one digital strip and an anlog one, WLED already manage this without any external software. You would only need to set one mosfet as the main relay, and the other one as a PWM driving signal. YULC offers a great versatility from this point of view.\nSo, to configure two digital strip go to Config -&gt; LED Preferences and set everything up like the following picture with your own strips type and lengths. Also check “Make a segment for each output”\n\n\n\n\n\nNow go back to Config -&gt; Usermods and, again, follow the picture, then save. This usermod has 4 pre-defined relays, but you only need the first two. Pin 47 is linked to Channel 1 (DATA 1 on the PCB) and pin 21 to Channel 2. Check also “External” on both, so we can control these relays through the dedicated APIs.\n\n\n\n\n\nAt this point we can physically toggle both segments through built-in mosfets combining both WLED and Multi Relay JSON API. Keep in mind that the WLED main button will still turn off all the segments at once. The calls you need are:\n\n//Switching on the mosfet #0 to power the first segment/strip\ncurl -X POST -H \"Content-Type: application/json\" -d ''{\"MultiRelay\":{\"relay\":0,\"on\":true}}'' \"http://your-ip-address/json\"\n\n//Turning on \"software\" the segment with ID #0\ncurl -X POST -H \"Content-Type: application/json\" -d ''{\"seg\":[{\"id\":0,\"on\":true}]}'' \"http://your-ip-address/json/state\" \nWhen switching on you’ll want to physically turn on the strip before turning on via software. Instead, when switching off, it would be better to reverse the sequence. Basically there should not be data signals to led strips while they are physically disconnected from the power supply.\nIf you are an Home Assistant user, you can easily integrate these controls as light entities using some shell commands:\nshell_command:\n  strip_1_on: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"seg\":[{\"id\":0,\"on\":true}]}'' \"http://your-ip-address/json/state\"'\n  strip_1_mos_on: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"MultiRelay\":{\"relay\":0,\"on\":true}}'' \"http://your-ip-address/json\"'\n  strip_1_off: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"seg\":[{\"id\":0,\"on\":false}]}'' \"http://your-ip-address/json/state\"'\n  strip_1_mos_off: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"MultiRelay\":{\"relay\":0,\"on\":false}}'' \"http://your-ip-address/json\"'\n  strip_2_on: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"seg\":[{\"id\":1,\"on\":true}]}'' \"http://your-ip-address/json/state\"'\n  strip_2_mos_on: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"MultiRelay\":{\"relay\":1,\"on\":true}}'' \"http://your-ip-address/json\"'\n  strip_2_off: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"seg\":[{\"id\":1,\"on\":false}]}'' \"http://your-ip-address/json/state\"'\n  strip_2_mos_off: 'curl -X POST -H \"Content-Type: application/json\" -d ''{\"MultiRelay\":{\"relay\":1,\"on\":false}}'' \"http://your-ip-address/json\"'\n    \nlight:\n  - platform: template\n    lights:\n      strip_1:\n        turn_on:\n          - service: shell_command.strip_1_mos_on\n          - service: shell_command.strip_1_on\n        turn_off:\n          - service: shell_command.strip_1_off\n          - service: shell_command.strip_1_mos_off\n      strip_2:\n        turn_on:\n          - service: shell_command.strip_2_mos_on\n          - service: shell_command.strip_2_on\n        turn_off:\n          - service: shell_command.strip_2_off\n          - service: shell_command.strip_2_mos_off\nNow you have two completely separated strips from every point of view.\n\n\n\n\n\nSTRIP AS A TIMER\nI made this simple usermod to use the connected strip as a visual timer that you can control through some MQTT commands. I really like how it turned out and I think it could be a funny and eye-catching countdown.\nFirst of all, you need to enable MQTT checking Config -&gt; Sync Interfaces -&gt; Enable MQTT in WLED settings. Then fill the required parameters to connect to your MQTT broker.\n\n\n\n\n\nBasically, When the timer starts, the strip is filled with green color. Leds are turned off according to the remaining time of the timer and the color starts changing being red when the timer has ended. MQTT messages to use the timer are:\n\n(device topic)/timerbar with payload “+X” where X is the duration of the timer in seconds. If there’s no active timer, with this command the timer starts with a duration of X. If there is already a running timer, the same command adds X seconds to timer. In this case the strip is not filled again, but leds will start to turn off slower and the already turned off leds will remain off.\n\n\n\n\n\n\n\nNote\n\n\n\nFrom the image, the command will be wled/bedroom/timerbar with payload +X\n\n\n\n(device topic)/timerbar with payload “STOP” -&gt; This message ends the timer.\n\n\n\n\n\n\n\nNote\n\n\n\nThe command will be wled/bedroom/timerbar with payload STOP\n\n\nEverytime the timer ends, the strip returns in the previous state (effect, palette…)",
    "crumbs": [
      "YULC"
    ]
  },
  {
    "objectID": "documentation/esp360/esp360.html",
    "href": "documentation/esp360/esp360.html",
    "title": "ESP 360 Remote",
    "section": "",
    "text": "This board boasts a RF transmitter and receiver, while IR LEDs are arranged in a circle to provide omnidirectional coverage. Additionally, it comes equipped with a temperature and humidity sensor, as well as an ambient light sensor. To top it off, the board can be powered and programmed through a USB Type-C port, which is ESD protected. Based on the ESP32-WROOM-32E, this board can be effortlessly configured with ESPHome, allowing for seamless control via Home Assistant. You can swap the 433MHz modules with 315MHz ones because the SRX/STX882 modules come in both version with the same pinout, so you can choose which one fit your needs the best\nI think the form factor it’s nice because there are two round stackable layers.\nThe first layer of the board includes the ESP32, the two sensors, the buck converter and the USB circuitry.\nThe second layer of the board features the IR leds and receiver and the RF modules.\nInside the enclosure just stack the two layers using the x8 female header near the ESP:\nThen screw the top part and turn the board on!\nNow you can also program the board with the USB-C. I suggest to use ESPHOME beacuse it’s super easy to setup and to integrate with Home Assistant",
    "crumbs": [
      "ESP 360 REMOTE"
    ]
  },
  {
    "objectID": "documentation/esp360/esp360.html#transmitting-signals",
    "href": "documentation/esp360/esp360.html#transmitting-signals",
    "title": "ESP 360 Remote",
    "section": "Transmitting signals",
    "text": "Transmitting signals\nThanks to the ease of use of ESPHome, you can create custom switches or integrate existing components (see https://esphome.io/components/climate/climate_ir.html) by directly modifying the yaml file, and all of this will be immediately visible on Home Assistant. Alternatively, if you want to take an even simpler route, you can use two integrated services to send raw IR and RF signals:\n\n\n\n\n\nThis way you won’t need to tinker with the ESPHome configuration and you’ll be able to send signals directly from your automations!",
    "crumbs": [
      "ESP 360 REMOTE"
    ]
  },
  {
    "objectID": "documentation/esp360/esp360.html#receiving-signals",
    "href": "documentation/esp360/esp360.html#receiving-signals",
    "title": "ESP 360 Remote",
    "section": "Receiving signals",
    "text": "Receiving signals\nWhen the board receives an RF signal, the esphome.rf_code_received event will be triggered in Home Assistant. From there, you can directly see the protocol and code of the received signal. The same feature will soon be available for the infrared receiver as well.\n\n\n\n\n\nIn this case, I received the code 721136 (10110000000011110000 in binary) and protocol 2",
    "crumbs": [
      "ESP 360 REMOTE"
    ]
  },
  {
    "objectID": "documentation/esp360/esp360.html#smartir-integration",
    "href": "documentation/esp360/esp360.html#smartir-integration",
    "title": "ESP 360 Remote",
    "section": "SmartIR Integration",
    "text": "SmartIR Integration\nESPHome ensures compatibility with the widely-used SmartIR custom component for Home Assistant, thanks to its built-in support for transmitting raw signals. If you already have a SmartIR configuration in place, all you need to do is specify the appropriate service for transmitting signals and a code that is compatible with ESPHome. Here’s an example of what your configuration.yaml file could look like:\nsmartir:\n\nclimate:\n  - platform: smartir\n    name: Livingroom AC\n    unique_id: livingroom_ac\n    device_code: 7065\n    controller_data: esp360remote_send_ir_raw\n    temperature_sensor: sensor.living_room_temperature\nFor more information, check out the SmartIR repo.",
    "crumbs": [
      "ESP 360 REMOTE"
    ]
  },
  {
    "objectID": "documentation/esp360/quickstart.html",
    "href": "documentation/esp360/quickstart.html",
    "title": "ESP-360-REMOTE",
    "section": "",
    "text": "Insert the base of the ESP 360 Remote into the case and make sure that all the openings align, as well as the 3 holes in the PCB with the 3 plastic pins.\n\n\n\n\n\n\n\n\nInsert the RF modules into the upper part of the PCB as shown in the picture and manually raise the infrared LEDs to a 45° angle. They are currently bent horizontally for transportation safety reasons.\n\n\n\n\n\n\n\n\nInsert the top PCB all the way into the base through the 8-pin connector.\n\n\n\n\n\n\n\n\nClose the case by screwing the top part, plug in the power cable, and wait for the board’s hotspot called Esp360Remote or Esp360Remote2 (if you ordered the teo pack) to appear!"
  },
  {
    "objectID": "documentation/esp360/quickstart.html#install",
    "href": "documentation/esp360/quickstart.html#install",
    "title": "ESP-360-REMOTE",
    "section": "",
    "text": "Insert the base of the ESP 360 Remote into the case and make sure that all the openings align, as well as the 3 holes in the PCB with the 3 plastic pins.\n\n\n\n\n\n\n\n\nInsert the RF modules into the upper part of the PCB as shown in the picture and manually raise the infrared LEDs to a 45° angle. They are currently bent horizontally for transportation safety reasons.\n\n\n\n\n\n\n\n\nInsert the top PCB all the way into the base through the 8-pin connector.\n\n\n\n\n\n\n\n\nClose the case by screwing the top part, plug in the power cable, and wait for the board’s hotspot called Esp360Remote or Esp360Remote2 (if you ordered the teo pack) to appear!"
  },
  {
    "objectID": "documentation/esp360/quickstart.html#connect-to-home-assistant",
    "href": "documentation/esp360/quickstart.html#connect-to-home-assistant",
    "title": "ESP-360-REMOTE",
    "section": "Connect to Home Assistant",
    "text": "Connect to Home Assistant\n\nStep 1\nWhen the fallback hotspot is available, connect to it with Esp360Remote as password (for both of the AP’s name)\n\n\n\n\n\n\n\nStep 2\nAfter connecting to its hotspot, go to ip: 192.168.4.1 on your web browser, connect to your WiFi and you are done! Home Assistant should have now discovered your Esp 360 Remote!\n\n\n\n\n\n\n\nStep 3\nNow you can go to the ESPHome dahsboard on your Home Assistant instance and create a new project clicking on the bottom-right “+” icon. Choose the name you want.\n\n\n\n\n\n\n\nStep 4\nNow click on “skip this step” and then select the ESP32 in the next window.\n\n\n\n\n\n\n\n\n\n\n\n\nStep 5\nNow it will appear your new encryption key. You can save it somewhere and use it to modify the one in the default template, then click “SKIP”.\n\n\n\n\n\n\n\nStep 6\nAt this point, you should have your new project in the dashboard. Then click “EDIT”, remove everything inside and copy and paste the default configuration. Use both the yaml files if have two boards. Then you can change the encryption key if with the one you saved before and be sure to change the WiFi settings with your credentials, otherwise it will create again its own hotspot. After you’ve done that, you can click “SAVE”, then “INSTALL” and select “WIRELESSLY”. If you’ve done everything correctly, you should be see your device online in the dashboard and should be able to modify their configuration!"
  },
  {
    "objectID": "documentation/esp360/install.html",
    "href": "documentation/esp360/install.html",
    "title": "ESP-360-REMOTE",
    "section": "",
    "text": "Introduction\nTo start, follow the quick start guide just for the installation part.\nIf you know ESPHome, you can skip most of this document and just use the template in the ESPHome Configuration folder.\nIf you don’t know much about ESPHome this document will guide you through the installation process. If you need more information you can head to Discord and if you see something that is not clear enough, do not hesitate to make a pull request and improve the documentation for everybody.\n\n\nFirst step\nFor this step you will require a USB-C cable that has power + data (a normal cable should but some cheap aliexpress cable only have the power wire and no data wire) and a computer with chrome or edge browser (no firefox) open the following link in your browser once the device is connected to your computer using the USB-C cable you need to click on “connect”.\n\n\n\n\n\nSelect the USB-Serial device, if no USB serial device appear, ensure your USB cable is good and that you have the CH240X driver (the tool give you the link to install the driver if needed)\n\n\n\n\n\nOnce you are connected you should be able to click there :\n\n\n\n\n\nThe process takes a few minutes and ask for your wifi credentials toward the end so that the device can connect to your network. once it’s done you should be able to access the webpage hosted by the ESP 360 Remote\n\n\n\n\n\nAs you can see it’s empty. this is only the generic ESPHome configuration. follow to the next section to compile the firmware with the IR, RF and sensors feature\nNow, if you want to change the yaml file and update your ESP 360 Remote directly from the command line, you can jump to the Command Line section, otherwise if you would like to manage your board from an intuitive web page, go to the ESPHome Environment one.\n\n\nCommand Line\nFirst follow this guide that will help you install the compiler for the ESPhome firmware. ESPHome tool desktop installation. Now you can use the templates in the Template section and follow this guide (under the First uploading section) to compile the template provided here for your device : ESPHome tool desktop usage. You can now jump to the Template section\n\n\nESPHome Environment\nThis option require docker but allow you to manage in an easier way your fleet of esphome device\n\n\n\n\n\nI assume you know the docker basics, here is a docker-compose.yml that you can use to run the ESPhome “fleet manager”\nversion: '3'\nservices:\n  esphome:\n    container_name: esphome\n    image: ghcr.io/esphome/esphome\n    volumes:\n      - /path/to/esphome/config:/config\n      - /etc/localtime:/etc/localtime:ro\n    restart: always\n    privileged: true\n    network_mode: host\n    environment:\n      - USERNAME=test\n      - PASSWORD=ChangeMe\nEdit the username + password and the path to your configuration (just an empty folder is good, we will create the file from the web interface)\nOnce it’s running you can can access it on http://127.0.0.1:6052/ From there you can create a new device\n\n\n\n\n\nOnce done, click on skip for the install and click “edit” instead from the main menu :\nReplace the text with the one found in the ESPHome Configuration folder. as explained in the template section of this file once happy with your config you can compile by clicking save then come back to the main menu and click the “…” then install\n\n\n\n\n\nChoose manual download\n\n\n\n\n\nThe file will be compiled to a .bin that you will be able to download. You need to download the legacy format :\n\n\n\n\n\n\n\n\n\n\nFrom there, give it a name and choose ESP32\n\n\n\n\n\nNow return to the webpage of the ESP 360 Remote and under OTA Update browse for the file you previously downloaded and click update once the device as rebooted, you should see the value from the sensors and your switch\n\n\n\n\n\nyou are done :)\n\n\nTemplate\nHere is what the template looks like. you can edit the name field and the wifi ssid + password with your\nesphome:\n  name: esp360-default-1\n  friendly_name: ESP360-default-1\n\nesp32:\n  board: esp32dev\n  framework:\n    type: arduino\n\n# Enable logging\nlogger:\n\napi:\n  encryption:\n    ...\nYou can add your own action. This is an example that send an IR code that turn ON and OFF a fan. You will need to adapt the transmit_nec function to your protocol and replace the address and command field accordingly\n  - platform: template\n    name: \"fan\"\n    turn_on_action:\n      remote_transmitter.transmit_nec:\n        transmitter_id: IR_TX\n        address: 0xFE01\n        command: 0xE21D\n    turn_off_action:\n      remote_transmitter.transmit_nec:\n        transmitter_id: IR_TX\n        address: 0xFE01\n        command: 0xE21D\nIf you don’t know these, you can start by compiling the base template and go to the webpage of the ESP 360 remote, you should see a terminal that display the data from the sensors and the IR + RF transceiver just point the remote you want to clone toward the ESP 360 remote and look at the code display in the terminal. It should looks like something like this :\n\n\n\n\n\nThe line that we care about is the following\nReceived NEC: address=0xFE01, command=0xE21D\nThis line give you the protocol (NEC) the address and the command. if you have another protocol lookup in the ESPhome documentation the specific syntax.\nEdit the example template with your value and add as many as you need for every function of your remote you want to clone and use from the ESP 360 Remote.\n(dont hesitate to read the ESPhome documentation as it will give you more detailed info and more options to configure your actions)"
  },
  {
    "objectID": "documentation/flashing/flashing.html",
    "href": "documentation/flashing/flashing.html",
    "title": "Flash your device",
    "section": "",
    "text": "Here you can flash your product directly from your browser. In order to do that, please use a chromium-based browser.\n\nConnect your device\nSelect the type of product\nFlash!\n\n\n\n\n\nSoftware installer\n\n\n\n\nSelect your product\n\n\n\n YULC\n\n\n ESP 360 REMOTE",
    "crumbs": [
      "Flashing"
    ]
  },
  {
    "objectID": "documentation/yulc/hw_revisions.html",
    "href": "documentation/yulc/hw_revisions.html",
    "title": "YULC",
    "section": "",
    "text": "This first version consists in a single channel 5V Led controller.\nIt uses the STUSB4500 IC from ST to handle the PD delivery. This module must is configured by the ESP32 using I2C protocol through which is set the voltage the IC should ask for to the chargers. It can ask up to 20V and convert to 5V to the output.\nThe microncontroller is an ESP32-WROOM-32E and using an CP2102 it can be programmed through the USB-C port.\nThere should also be a mosfet to turn off the strips but the footprint was the wrong one, so that does not work."
  },
  {
    "objectID": "documentation/yulc/hw_revisions.html#yulc-v1.0",
    "href": "documentation/yulc/hw_revisions.html#yulc-v1.0",
    "title": "YULC",
    "section": "",
    "text": "This first version consists in a single channel 5V Led controller.\nIt uses the STUSB4500 IC from ST to handle the PD delivery. This module must is configured by the ESP32 using I2C protocol through which is set the voltage the IC should ask for to the chargers. It can ask up to 20V and convert to 5V to the output.\nThe microncontroller is an ESP32-WROOM-32E and using an CP2102 it can be programmed through the USB-C port.\nThere should also be a mosfet to turn off the strips but the footprint was the wrong one, so that does not work."
  },
  {
    "objectID": "documentation/yulc/hw_revisions.html#yulc-v2.0",
    "href": "documentation/yulc/hw_revisions.html#yulc-v2.0",
    "title": "YULC",
    "section": "YULC v2.0",
    "text": "YULC v2.0\n\n\n\n\n\nThis version comes with a lot of upgrades compared to the v1.0:\n\n2 Channels\nNewer ESP32-S3\nDual power supply possibility\n5V or 12V regulated output (or direct)\nFuses\nLevel shifters\nAble to power from ext. power supply and program the ESP at the same time.\nMosfets for both channels\n\nEverything works correctly excepts for the mosfets. THey switch the negative terminal and, while it’s working for analog strips, it does not work for the dgital ones. The current must find another path to GND, making mosfets useless"
  },
  {
    "objectID": "documentation/yulc/hw_revisions.html#yulc-v2.1",
    "href": "documentation/yulc/hw_revisions.html#yulc-v2.1",
    "title": "YULC",
    "section": "YULC v2.1",
    "text": "YULC v2.1\n\n\n\n\n\nIn this version I fixed some small things. Compared to v2.0, the two mosfets are now on the top layer, to be able to put the heatsink on both. I also re-arranged the two P-Mosfets on the USB-C Power bus, to allow a better routing for the input capacitors of the main buck converter. Now they are much closer, leading to a better overall behaviour of the IC.\nThe inductor has changed and I also added the JST connector for the 5V fan.\nThe 3 mounting holes are now standardized, and M2 screws fit very well.\nNow the mosfets switch the positive side thanks to two MX5014S, an high side mosfets driver. It’s quite cool because its connections are really simple, it can work up to 50V; it does not need an external bootstrap capacitor and can stay on for ever, so 100% duty cycle without any problems.\nThanks to this IC, mosfets now works flawlessly for both digital and analog strips.\nNow there are more output terminals to reduce the overall resistance of the serie BUCK IC + POWER INDUCTOR + FUSE + TERMINALS. With the new inductor and more parallel terminals, the resistance dropped from around 25 mOhm v2.0 to 12/13 mOhm. Testing this new version, with a current of 19A, I have around of 250/300mV drop compared to 400mV of the v2.0. So From 5V to 4.7V instead 4.6V\nFor the test, the input voltage is 19V and it’s regulated down to 5V through the buck converter.\n\n\n\nOutput resistance v2.0 @ 5V output\n\n\n\n\n\nOutput resistance v2.1 @ 5V output\n\n\nThis version also performs really well with 12V output converting a lot of power. Here it’s converting 164 W from a 24V input keeping an overall temperature &lt; 50°C after a 4hrs long test. The output resistance is even less than the other test (11mOhm vs 12/13mOhm). Probably less ripple current in the inductor.\n\n\n\nOutput resistance v2.1 @ 12V output"
  }
]